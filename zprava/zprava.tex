\documentclass{article}
\usepackage{minted}
\usepackage{cprotect}
\usepackage{hyperref}
\oddsidemargin=-5mm
\evensidemargin=-5mm\marginparwidth=.08in \marginparsep=.01in
\marginparpush=5pt\topmargin=-15mm\headheight=12pt
\headsep=25pt
%\footheight=12pt
\footskip=30pt\textheight=25cm
\textwidth=17cm\columnsep=2mm
\columnseprule=1pt\parindent=15pt\parskip=2pt
\renewcommand{\figurename}{Obrázek}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage[czech]{babel}
\newcommand{\heuristika}[1]{\textbf{\textit{Heuristika {#1}.}}}
\newcommand{\const}[1]{\mintinline{bash}{#1}}
\newcommand{\konstanta}[1]{\textbf{\textit{Konstanta}} \const{#1}.}

% minted centering
\usepackage{xpatch,letltxmacro}
\LetLtxMacro{\cminted}{\minted}
\let\endcminted\endminted
\xpretocmd{\cminted}{\RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}}{}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%http://ftp.cvut.cz/tex-archive/macros/latex/contrib/algorithm2e/doc/algorithm2e.pdf
%\usepackage[ruled,vlined]{algorithm2e}
\usepackage[linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
    \begin{center}
        \bf Semestrální projekt MI-PDP 2020/2021:\\[5mm]
        Paralelní algoritmus pro řesení problému prohledávání stavového prostoru\\[5mm]
        Martin Šafránek\\[2mm]
        magisterské studijum, FIT ČVUT, Thákurova 9, 160 00 Praha 6\\[2mm]
        zdrojové kódy:\\ \url{https://github.com/TaIos/ni-pdp-semestralka}\\[2mm]
        \today
    \end{center}


    \label{sec:sequential}


    \section{Definice problému a popis sekvenčního algoritmu}

    Program řeší problém nalezení optimální posloupnosti tahů pro střelce a jezdce, která vede k sebrání
    všech pěšců rozmístěných na šachovnici. Jedná se o analogii problému obchodního cestujícího.
    Nalezení optimálního řešení je proto NP těžký úkol. Řešení v této práci používá bruteforce
    s heuristikami pro ořezávání stavového prostoru.
    \newline

    \label{subsec:popis-vstupu}

    \subsection{Popis vstupu}
    Příklad vstupu je uveden na obrázku \ref{fig:board-example}. Obsahuje popořadě vždy
    \begin{enumerate}
        \item přirozené číslo $k$, reprezentující délku strany šachovnice $S$ o velikosti $k \times k$,
        \item horní mez délky optimální posloupnosti $d^{*}_{max}$,
        \item pole souřadnic rozmístěných figurek na šachovnici S.
    \end{enumerate}

    \begin{figure}[h]
        \begin{center}
            \begin{BVerbatim}
                11
                22
                -----------
                -------P---
                P-----P--P-
                ---PJS--P--
                ----P------
                ---P--P----
                ------P----
                ------P----
                ------P----
                -----PP----
                -----------
            \end{BVerbatim}
        \end{center}
        \cprotect\caption{ Příklad vstupních dat pro $k=11$, $d^{*}_{max}=22$. Střelec je označen \verb|S|, jezdec \verb|J|,\
            pěšák \verb|P| a prázdné políčko \verb|-|. }
        \label{fig:board-example}
    \end{figure}


    \label{subsec:seq-heuristics}

    \subsection{Heuristiky}

    Sekvenční algoritmus používá dvě heuristiky pro pohyb střelce a koně.

    \heuristika{střelec} Z množiny možných políček, kam je možné střelce přemístit jsou preferována ty,
    která obsahují pěšce. Pokud takové políčko neexistuje, jsou preferována políčka s alespoň jedním pěšákem
    na diagonále. Jinak se pohyb střelce rozhodne náhodně.
    \hspace{1.5pt}

    \heuristika{kůň} Z množiny možných políček, kam je možné koně přemístit jsou preferována ty,
    která obsahují pěšce. Pokud takové políčko neexistuje, jsou preferována políčka, z kterých
    kůň ve svém následujícím tahu může vzít pěšáka. Pokud ani takové políčko neexistuje, jsou
    preferováno políčka, z kterých kůň v následujícíh dvou tazích může vzít pěšáka.
    Jinak se pohyb koně rozhodne náhodně.

    \subsection{Pseudokód}
    \begin{algorithm}[H]
        \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
        \SetAlgorithmName{Algoritmus}
        \SetAlgoLined

        \Input{$k\times k$ pole, mez $d^{*}_{max}$}
        \Output{optimální posloupnost tahů}
        \BlankLine

        \eIf{abc or def}{

        }\;
        \While{While condition}{
            instructions\;
            \eIf{condition}{
                instructions1\;
                instructions2\;
            }{
                instructions3\;
            }
        }
        \caption{sekvenční}
        \label{alg:sequential}
    \end{algorithm}

    \label{sec:task-par}


    \section{Popis paralelního algoritmu a jeho implementace v OpenMP - taskový paralelismus}

    Taskový paralelní algoritmus je naimplementován pomocí OpenMP. Hlavní rozdíl oproti sekvenčnímu algoritmu
    popsaném v \ref{sec:sequential} je rozdělení úlohy prohledávání stavového prostoru na tasky. Task je
    základní jednotka, kterou je OpenMP schopno přidělit vláknu a provést tak výpočet. Pro zadanou úlohu
    task znamená šachovnici s pozicí všech figurek a historií tahů. Takto vytvořené tasky OpenMP přidává
    do svého taskpoolu, z kterého si je vlákna vyzvedávají a řeší. Dále všechny vlákna řešící tasky z
    taskpoolu sdílejí nejlepší řešení $d_{best}$. Heuristiky jsou totožné jako v podsekci \ref{subsec:seq-heuristics}.

    \subsection{Konstanty a parametry pro škálování algoritmu}
    Taskový paralelní algoritmus implementovaný pomocí OpenMP umožňuje nastavení konstant, které ovlivní
    logiku funkce programu a tedy i výpočetní čas. Změněny byly pouze zde zmíněné konstanty. Jejich hodnota
    byla určena empiricky na vstupních datech. Nejedná se o optimální hodnoty, protože jejich nalezení je
    stejně těžký problém jako nalezení optimální cesty v původním problému.

    \konstanta{TASK_THRESHOLD}  Pokud vlákno řeší instanci a délka její cesty je delší než \const{TASK_THRESHOLD}, nevytváří další
    OpenMP tasky a nepřidává je do taskpoolu. Zadanou instaci vyřeší použitím sekvenčního algoritmu popsaném v sekci \ref{sec:sequential}.

    \begin{table}[hb]
        \centering
        \begin{tabular}{|l|l|}
            \hline
            název                  & hodnota \\ \hline
            \const{TASK_THRESHOLD} & 6       \\ \hline
        \end{tabular}
        \caption{Konstanty použité v OpenMP taskovém paralelismu.}
        \label{tab:data-par-constants}
    \end{table}

    \subsection{Pseudokód}

    \begin{algorithm}[H]
        \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
        \SetAlgorithmName{Algoritmus}
        \SetAlgoLined

        \Input{$k\times k$ pole, mez $d^{*}_{max}$}
        \Output{optimální posloupnost tahů}
        \BlankLine

        \eIf{abc or def}{

        }\;
        \While{While condition}{
            instructions\;
            \eIf{condition}{
                instructions1\;
                instructions2\;
            }{
                instructions3\;
            }
        }
        \caption{OpenMP taskový paralelismus}
        \label{alg:task-par}
    \end{algorithm}


    \label{sec:data-par}
    \section{Popis paralelniho algoritmu a jeho implementace v OpenMP - datový paralelismus}
    Datový paralelismus v OpenMP pracuje s datově nezávislými celky, které podle určené
    strategie přiděluje vláknům na zpracování. Nezávislý datový celek je pro zadanou úlohu
    šachovnice s pozicí všech figurek a historií tahů.

    První krok je vygenerování datově nezávislých celků – to je provedeno před použitím OpenMP.
    Ty jsou následně najednou předány OpenMP. To je určenou strategií rozdělí mezi vlákna.
    Každé vlákno pak provádí sekvenční řešení problému popsané v sekci \ref{sec:sequential}.
    Vlákna mezi sebou sdílejí pouze nejlepší řešení.

    \subsection{Konstanty a parametry pro škálování algoritmu}
    Prvním krokem před spuštěním OpenMP řešení je vytvoření datově nezávislých instancí.
    Ty se vytvoří použitím sekvečního algoritmu, viz sekce \ref{sec:sequential}.
    Jejich počet je regulován konstantou \const{EPOCH_CNT}.

    Parametrem OpenMP je konstanta \const{schedule}. Ta určuje politiku přidělování datově nezávislých instací vláknům.
    Zde je použitá hodnota \const{dynamic()} bez parametrů. To znamená, že pokud vlákno dokončí výpočet je mu
    přiřazena jedna další datově nezávislá instance k vyřešení.

    \konstanta{EPOCH_CNT} Určuje, kolik datově nezávislých instancí je vygenerováno.
    Pro každou epochu jsou provedeny všechny možné tahy buď koněm, nebo střelcem.
    Po vyčerpání všech epoch jsou stavy, do kterých se kůň a střelec dostali
    použity jako nezávislé instance.

    \konstanta{schedule} OpenMP konstanta, která nastavuje politiku přidělování datově nezávislých instací vláknům.

    \begin{table}[hb]
        \centering
        \begin{tabular}{|l|l|}
            \hline
            název      & hodnota \\ \hline
            \const{EPOCH_CNT} & 3       \\ \hline
            \const{schedule} & dynamic()      \\ \hline
        \end{tabular}
        \caption{Konstanty použité v OpenMP datovém paralelismu}
        \label{tab:data-par-constants}
    \end{table}

    \subsection{Pseudokód paralelního algoritmu — datový paralelismus}
    Porchetta andouille flank kielbasa. Tail biltong turducken porchetta burgdoggen ground round shoulder ham, hamburger bacon shankle landjaeger fatback pork belly doner. Sirloin doner venison shankle cow, hamburger flank sausage pork belly. Tenderloin venison pancetta corned beef tongue cow pork belly capicola ball tip salami short ribs. Sirloin rump andouille tail shank fatback bresaola.

    Leberkas ham bacon, pastrami turducken pork belly cupim salami kielbasa doner. Turkey cupim meatball capicola jowl cow shank chicken drumstick kevin salami swine pork belly. Drumstick leberkas corned beef beef short loin boudin. Turkey strip steak bacon, ball tip sirloin pork loin pork.

    \subsection{Pseudokód}

    \begin{algorithm}[H]
        \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
        \SetAlgorithmName{Algoritmus}
        \SetAlgoLined

        \Input{$k\times k$ pole, mez $d^{*}_{max}$}
        \Output{optimální posloupnost tahů}
        \BlankLine

        \eIf{abc or def}{

        }\;
        \While{While condition}{
            instructions\;
            \eIf{condition}{
                instructions1\;
                instructions2\;
            }{
                instructions3\;
            }
        }
        \caption{OpenMP datový paralelismus}
        \label{alg:data-par}
    \end{algorithm}


    \section{Popis paralelního algoritmu a jeho implementace v MPI}
    
    Řešení s použitím MPI se skládá ze dvou částí. První je datový OpenMP paralelismus, 
    viz sekce \ref{sec:data-par}. Druhou část tvoří MPI. Ten má za úkol řídit a distribuovat
    výpočet na několika výpočetních uzlech.

    MPI proces začíná tím, že si master vlákno identickým způsobem jako v sekci s datovým paralelismem\ref{sec:data-par}
    vygeneruje datově nezávislé instance. Ty pak serializuje a společně s globálním nejlepším řešením je
    pošle přes MPI interface slavům. Každý z nich pomocí datového paralelismu popsaného v sekci \ref{sec:data-par}
    vyřeší přijmuté řešení a odešlě ho zpět master vláknu. Pak požádá master vlákno o další instanci k vyřešení.
    Pokud master vláknu dojdou instance k vyřešení, rozešlě slavům zprávu o ukončení výpočtu.

    \subsection{Konstanty a parametry pro škálování algoritmu}
    Protože MPI využívá pro řešení tasků datový OpenMP paralelismus popsaný v sekci \ref{sec:data-par}, jsou
    zde uvedeny pouze MPI konstanty.

    TODO nastaveni poctu vypocetnich jader

    \subsection{Pseudokód}

    \begin{algorithm}[H]
        \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
        \SetAlgorithmName{Algoritmus}
        \SetAlgoLined

        \Input{$k\times k$ pole, mez $d^{*}_{max}$}
        \Output{optimální posloupnost tahů}
        \BlankLine

        \eIf{abc or def}{

        }\;
        \While{While condition}{
            instructions\;
            \eIf{condition}{
                instructions1\;
                instructions2\;
            }{
                instructions3\;
            }
        }
        \caption{MPI paralelismus}
        \label{alg:mpi}
    \end{algorithm}


    \section{Naměřené výsledky a vyhodnocení}

    \begin{enumerate}
        \item Zvolte tri instance problemu s takovou velikosti vstupnich dat, pro ktere ma sekvencni
        algoritmus casovou slozitost mezi 1 a 10 minutami.
        Pro mereni cas potrebny na cteni dat z disku a ulozeni na disk neuvazujte a zakomentujte
        ladici tisky, logy, zpravy a vystupy.
        \item Merte paralelni cas pri pouziti $i=2,\cdot,60$ vypocetnich jader.
        \item Tabulkova a pripadne graficky zpracovane namerene hodnoty casove slozitosti měernych instanci behu programu s popisem instanci dat. Z namerenych dat sestavte grafy zrychleni $S(n,p)$.
        \item Analyza a hodnoceni vlastnosti paralelniho programu, zvlaste jeho efektivnosti a skalovatelnosti, pripadne popis zjisteneho superlinearniho zrychleni.

    \end{enumerate}


    \section{Závěr}

    Celkove zhodnoceni semestralni prace a zkusenosti ziskanych behem semestru.

    Porchetta andouille flank kielbasa. Tail biltong turducken porchetta burgdoggen ground round shoulder ham, hamburger bacon shankle landjaeger fatback pork belly doner. Sirloin doner venison shankle cow, hamburger flank sausage pork belly. Tenderloin venison pancetta corned beef tongue cow pork belly capicola ball tip salami short ribs. Sirloin rump andouille tail shank fatback bresaola.

    Leberkas ham bacon, pastrami turducken pork belly cupim salami kielbasa doner. Turkey cupim meatball capicola jowl cow shank chicken drumstick kevin salami swine pork belly. Drumstick leberkas corned beef beef short loin boudin. Turkey strip steak bacon, ball tip sirloin pork loin pork.

    Doner tenderloin chislic rump shank sausage beef andouille. Frankfurter boudin strip steak ribeye, venison biltong beef. Drumstick ham hock pork chop buffalo rump. Beef ribs sausage filet mignon pork chop flank jerky.


    \newpage
    \section{Skript pro spouštění a sekvenčního a OpenMP řešení}
    Bash skript v \ref{listing:shellrun} spustí program, kterému v argumentu předá vstupní data jako textový soubor.
    Formát vstupních dat viz podsekce \ref{subsec:popis-vstupu}. Pro sekvenční řešení skript spouští všechny řešení najednou.
    Pro paralelní čeká vždy na dokončení běhu aktuálního vstupu.

    \begin{figure}[htp]
        \centering
        \begin{cminted}{bash}
            #!/usr/bin/bash

            PROGRAM='./run.out'
            OUT="out/parallel/data_epoch3_guided"

            mkdir "$OUT"

            for filename in ../data/*.txt; do
            base=$(basename -- "$filename")
            echo "$base"

            # sekvencni
            #  $PROGRAM "$filename" >"$OUT/$base" &

            # paralelni
            $PROGRAM "$filename" > "$OUT/$base"

            done
        \end{cminted}
        \caption{Bash skript pro spuštění sekvenčního a OpenMP programu.}
        \label{listing:shellrun}
    \end{figure}


    \section{Literatura}
    Tenderloin pork belly ham leberkas doner rump. Filet mignon beef pastrami pork belly drumstick. Beef ribs filet mignon porchetta pork turducken spare ribs tri-tip corned beef strip steak turkey capicola. Venison hamburger ball tip, buffalo fatback pork alcatra doner pork belly.


\end{document}
